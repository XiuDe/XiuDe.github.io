---
layout: original
title: "node系统回顾第四课"
date: 2017-10-15 22:18:49 +0800 
categories: node研究
tag: node
---
* content
{:toc}

- [http.createServer](http://nodejs.cn/api/http.html#http_http_createserver_requestlistener)
- [http.IncomingMessage 类](http://nodejs.cn/api/http.html#http_class_http_incomingmessage)
- [http.ServerResponse 类](http://nodejs.cn/api/http.html#http_class_http_serverresponse)

<!-- more -->


## Web开发概述
- Node.js服务器模型与php服务器模型的区别

![浅拷贝]({{'/styles/images/node/server.png'}})

```
    传统的动态网站开发需要应用软件
    PHP ： Apache + php模块
    java ：Tomcat 、Weblogic
    Node.js  : 不需要应用软件（可以自己实现，因为有接口），nodejs优势，先天支持高并发。
```

## Node.js实现服务器功能
- [http.createServer](http://nodejs.cn/api/http.html#http_http_createserver_requestlistener)

```
// 初步实现服务器
const http = require('http');
// 1. 创建服务器实例对象
let server = http.createServer();
// 2. 绑定请求事件，事件是文档中提供的
server.on('request',(req,res)=>{
    res.end('Hello');// 页面输出Hello
});
// 3. 监听端口
server.listen(3000);//80端口是默认端口，可以省略
// 4. 浏览器请求localhost:3000，命令退出ctrl+c

// 简单写法1
const http = require('http');
http.createServer((req,res)=>{
    res.end('ok');// 页面输出ok
}).listen(3000);

// 关于监听接口的参数，
http.createServer((req,res)=>{
    res.end('ok'); // 页面显示
}).listen(3000,'192.168.1.102',()=>{// 请求http://192.168.1.102:3000/
    console.log('running...'); // 命令窗口显示的内容
});

// 存在问题：无论请求http://192.168.1.102:3000/还是
             http://192.168.1.102:3000/index.html页面都是显示ok
             根据url不同显示相应界面-> 请求路径分发 
```

- nodejs的请求路径分发

```
/*
    处理请求路径的分发
    1、req对象是Class: http.IncomingMessage的实例对象
    2、res对象是Class: http.ServerResponse的实例对象
*/
const http = require('http');
http.createServer((req,res)=>{
    // req.url可以获取URL中的路径（端口之后部分）
    // res.end(req.url);
    if(req.url.startsWith('/index')){
        // write向客户端响应内容,可以写多次
        res.write('hello');
        res.write('hi');
        res.write('nihao');
        // end方法用来完成响应，只能执行一次
        res.end();
    }else if(req.url.startsWith('/about')){
        res.end('about');
    }else{
        res.end('no content');
    }
}).listen(3000,'192.168.1.102',()=>{
    console.log('running...');
});

```

## Node.js实现静态网站功能
- 实现静态服务器功能

```
/*
    响应完整的页面信息,apache可以实现，
    这里是nodejs的实现逻辑
*/
const http = require('http');
const path = require('path');
const fs = require('fs');

// 根据路径读取文件的内容，并且响应到浏览器端
let readFile = (url,res) => {
    fs.readFile(path.join(__dirname,'www',url),'utf8',(err,fileContent)=>{
        if(err){
            res.end('server error');
        }else{
            res.end(fileContent);
        }
    });
}

http.createServer((req,res)=>{
    // 处理路径的分发
    if(req.url.startsWith('/index')){ //index.html文件
        readFile('index.html',res);
    }else if(req.url.startsWith('/about')){ //about.html文件
        readFile('about.html',res);
    }else if(req.url.startsWith('/list')){ //list.html文件
        readFile('list.html',res);
    }else{
        // 设置相应类型和编码
        res.writeHead(200,{
            'Content-Type':'text/plain; charset=utf8'
        });
        res.end('页面走丢了');
    }
}).listen(3000,'192.168.1.102',()=>{
    console.log('running...');
});/*
    响应完整的页面信息
*/
const http = require('http');
const path = require('path');
const fs = require('fs');

// 根据路径读取文件的内容，并且响应到浏览器端
let readFile = (url,res) => {
    fs.readFile(path.join(__dirname,'www',url),'utf8',(err,fileContent)=>{
        if(err){
            res.end('server error');
        }else{
            res.end(fileContent);
        }
    });
}

http.createServer((req,res)=>{
    // 处理路径的分发
    if(req.url.startsWith('/index')){
        readFile('index.html',res);
    }else if(req.url.startsWith('/about')){
        readFile('about.html',res);
    }else if(req.url.startsWith('/list')){
        readFile('list.html',res);
    }else{
        // 设置相应类型和编码
        res.writeHead(200,{
            'Content-Type':'text/plain; charset=utf8'
        });
        res.end('页面被狗狗叼走了');
    }
}).listen(3000,'192.168.0.106',()=>{
    console.log('running...');
});
```

- 对上面案例的优化

```
const http = require('http');
const path = require('path');
const fs = require('fs');

// 只能找到当前路径www文件夹下的相应html文件
http.createServer((req,res)=>{
    fs.readFile(path.join(__dirname,'www',req.url),(err,fileContent)=>{
        if(err){
            // 没有找到对应文件
            res.writeHead(404,{
                'Content-Type':'text/plain; charset=utf8'
            });
            res.end('页面丢失了');
        }else{
            res.end(fileContent);
        }
    });
}).listen(3000,()=>{
    console.log('running...');
});

// 浏览器根据不同的文件识别不同的类型(图片、html形式..)
// MIME类型来区别
```

- 案例再优化

```
/*
    响应完整的页面信息
*/
const http = require('http');
const path = require('path');
const fs = require('fs');
const mime = require('./mime.json');// 存储了MIME类型的所有格式
                                    // {".323": "text/h323"}

http.createServer((req,res)=>{
    fs.readFile(path.join(__dirname,'www',req.url),(err,fileContent)=>{
        if(err){
            // 没有找到对应文件
            res.writeHead(404,{
                'Content-Type':'text/plain; charset=utf8'
            });
            res.end('页面走丢了');
        }else{
            let dtype = 'text/html';// 默认的类型
            // 获取请求文件的后缀
            let ext = path.extname(req.url);
            // 如果请求的文件后缀合理，就获取到标准的响应格式
            if(mime[ext]){
                dtype = mime[ext];
            }
            // 如果响应的内容是文本，就设置成utf8编码
            if(dtype.startsWith('text')){
                dtype += '; charset=utf8'
            }
            // 设置响应头信息
            res.writeHead(200,{
                'Content-Type':dtype
            });
            res.end(fileContent);
        }
    });
}).listen(3000,()=>{
    console.log('running...');
});
```

## 参数传递与获取
- get参数获取
- post参数获取
